# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a bash-based Git toolkit that provides six core safety-first utilities for Git operations:
- `git-undo`: Safely undo commits while preserving changes in stashes
- `git-redo`: Restore previously undone commits from undo stashes  
- `git-stash`: Stash all changes including untracked and ignored files
- `git-clean-branches`: Clean up merged and orphaned branches
- `git-squash`: Squash all commits in a branch into the oldest commit
- `git-status`: Show branch fork points and pending commits

## Architecture

**Single File Structure**: All functions are defined in `git-toolkit.sh` using a shared utility pattern:
1. **Shared constants**: `PROTECTED_BRANCHES_PATTERN`, `DATE_FORMAT`
2. **Utility functions**: Prefixed with `_git_` for validation, confirmation, formatting
3. **Public functions**: Named `git-*` that follow the safety-first pattern:
   - Validation → Preview → Confirmation → Execution → Feedback

**Safety-First Pattern**: Every function validates repository state, shows what will happen, requires user confirmation, then executes with clear success/error reporting.

**Cross-Platform Compatibility**: Uses POSIX-compliant shell syntax, avoids bash-specific features, works on macOS/Linux/Unix.

## Commit Messages

**No Generated By Tags**: Never include "Generated with Claude Code" or "Co-Authored-By: Claude" in commit messages. Keep commit messages clean and focused on the actual changes.

**No AI Attribution**: Never use "Co-Authored-By:", "Co-Developed-By:", or any similar attribution tags for AI assistance in commit messages. Commit messages should only acknowledge human contributors and focus on the technical content of the changes.

## Development Commands

### Testing
```bash
# Run full test suite (63 tests across 8 categories)
./test-git-toolkit.sh

# ALWAYS test under both bash and POSIX sh for maximum compatibility
bash ./test-git-toolkit.sh    # Test under bash
sh ./test-git-toolkit.sh      # Test under POSIX sh

# Debug mode available for both shells
bash ./test-git-toolkit.sh --debug
sh ./test-git-toolkit.sh --debug

# Test specific function (modify test script to run individual test blocks)
# Tests are organized by function in the script with clear section headers
```

### Installation & Usage
```bash
# Source the toolkit in current shell
source git-toolkit.sh

# Add to shell profile for permanent installation
echo "source $(pwd)/git-toolkit.sh" >> ~/.bashrc
```

## Key Implementation Details

**Stash Management**: `git-undo` creates specially formatted stashes with metadata files that `git-redo` can identify and restore. Uses `"undo - TIMESTAMP - COMMIT_MSG"` naming pattern.

**Branch Protection**: All functions protect main/master/develop branches using `PROTECTED_BRANCHES_PATTERN` regex.

**Metadata Preservation**: `git-undo` stores commit hash, message, author, and timestamp in temporary files that get stashed for complete recovery information.

**Base Branch Detection**: `git-squash` and `git-status` automatically detect merge bases with main/master/develop, preferring develop over main when distances are equal.

**Error Handling**: Comprehensive validation at function start, graceful failure modes, and helpful error messages with cleanup.

## Testing Architecture

**Isolated Test Environment**: Each test creates temporary directories under `tests/test-*-$$` to avoid interfering with the parent git repository.

**Test Categories**: 63 tests organized into 8 categories covering error conditions, user interactions, safety mechanisms, and core functionality.

**Cross-Platform Testing**: Validates POSIX compliance, shell syntax compatibility, and timestamp edge cases.

**Development Testing**: All testing and debug sessions must be stored in `tests/` directory. This directory is gitignored to prevent interference with git operations and maintain a clean repository state.

**Test Requirements**: When writing or updating code, always write adequate tests and add them to `test-git-toolkit.sh`. If any tests are updated or added, always update the README.md test output section from the actual test script output (not derived), and update the test breakdown with accurate counts and categories.

**Dual Shell Testing**: ALWAYS run tests under both `bash` and `sh` to ensure POSIX compatibility. Both shells must pass all 63 tests. Any code changes must be validated against both environments before considering the work complete.

**Branch Agnostic Testing**: Tests must work in any Git environment regardless of default branch naming conventions. Never assume "main" or "master" - always detect the actual branch name dynamically.

## Shell Compatibility

Functions use POSIX-compliant syntax with specific considerations:
- Uses `sed` instead of bash parameter expansion for regex operations
- Avoids bash arrays and associative arrays
- Uses `read -r` for safe input handling
- Temporary files for complex operations to avoid subshell variable issues

**POSIX Shell Compatibility Issues**:
- **Function Naming**: POSIX sh doesn't allow hyphens in function names. All functions use underscores (e.g., `git_undo` not `git-undo`)
- **Source Command**: POSIX sh uses `.` instead of `source`. Always use `. script.sh` for compatibility
- **Echo Command**: `echo -e` is not portable. Use `printf` for escape sequences (e.g., `printf "1\ny\n"` instead of `echo -e "1\ny"`)
- **Reserved Variables**: Avoid using `status` as a variable name - it's read-only in some shells. Use descriptive names like `branch_status`
- **Default Branch Names**: Never hardcode "main" or "master" in tests. Use `$(git branch --show-current)` to detect the actual default branch name

**Test Accuracy and Branch Naming**:
- **Dynamic Branch Detection**: Always capture the actual default branch with `DEFAULT_BRANCH=$(get_default_branch)` in each test
- **User-Facing Messages**: All test output should use `$DEFAULT_BRANCH` instead of hardcoded "main" for accuracy
- **Generic Test Titles**: Use "default branch" or "protected branch" in test descriptions instead of "main branch"
- **Test Directory Names**: Use generic names like `test-squash-protected-$$` instead of `test-squash-main-$$`
- **Environment Independence**: Tests must work whether default branch is "main", "master", or any other name

**Backward Compatibility**: For users expecting hyphenated function names, conditional aliases are created only in interactive bash/zsh shells to avoid parse errors in POSIX sh

**Testing Protocol**: All changes must pass under both `bash ./test-git-toolkit.sh` and `sh ./test-git-toolkit.sh` commands

## Debug Mode and Variable Robustness

**Debug Mode**: `git-status --debug` provides detailed diagnostic information including branch detection, pattern matching, and code path selection. Essential for troubleshooting branch classification issues.

**Readonly Variable Handling**: The `PROTECTED_BRANCHES_PATTERN` variable can become corrupted (set to empty string) due to multiple script sourcing or environment issues. Robust handling includes:
- Length-based checking: `${#PROTECTED_BRANCHES_PATTERN} -eq 0`
- Fallback pattern in utility function to ensure valid regex even if main variable fails
- Override mechanism for readonly variable conflicts
- Never rely solely on `-z` test for pattern validation

**Pattern Matching Safety**: Empty regex patterns match everything, causing feature branches to be misclassified as protected branches. Always validate pattern content before use.

**Critical Pattern Usage**: Always use `$(_git_get_protected_pattern)` helper function instead of `$PROTECTED_BRANCHES_PATTERN` directly. The helper provides fallback logic when the pattern variable is corrupted or empty, preventing misclassification of all branches as protected.

**Branch Name Detection Best Practices**:
- Use `get_default_branch()` helper function to detect the actual default branch name
- Capture branch name early in each test: `DEFAULT_BRANCH=$(get_default_branch)`
- Never hardcode branch names in assertions, error messages, or user output
- Use generic terminology in test descriptions to avoid environment assumptions